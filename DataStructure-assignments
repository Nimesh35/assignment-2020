Q1)
#include<stdio.h>
#include<stdlib.h>

struct student
{
 char name[20];
 int rollno;
};
int main()
{
    struct student s1;
    strcpy(s1.name,"nimesh");
    s1.rollno=54;
    printf("name : %s,rollno : %d",s1.name,s1.rollno);
   
    
}
==============================================================================================================================
Q2)
#include<stdio.h>
#include<string.h>

struct student
 {
     int rollno;
     char name[30];
     
 };
 
int main()
{
    struct student *s1,s;
    s1=&s;
    
    s1->rollno=20;
    strcpy(s1->name,"Rahul");         

    printf("rollno :%d\n",s1->rollno);
    printf("name : %s\n",s1->name);
    
}
=========================================================================================================================
Q3)
#include<stdio.h>

struct employee
{
	int eid;
	char name[20];
	char city[20];
};

int main()
{
	struct employee e[3];
	char nm[20];
	char cy[20];
	int i;
	for(i=0;i<3;i++);
	{
		printf("enter id :");
		scanf("%d",&e[i].eid);
		
		fflush (stdin);
		printf("enter name :");
		gets(nm);
		strcpy(e[i].name,nm);
		
		fflush (stdin);
		printf("enter city :");
		gets(cy);
		strcpy(e[i].city,cy);
		fflush(stdin);
	}
	
	for(i=0;i<3;i++);
	{
		printf("id:%d, name:%s ,city:%s\n",e[i].eid,e[i].name,e[i].city);
	}
}
============================================================================================================================================
Q4)
#include<stdio.h>

int main()
{ 
 float num[]={1.2,1.3,1.4};
 float *p=num;
 
 int i;
 for(i=0;i<3;i++)
 {
 	printf("%.2f\t",*(p+i));n
 }
}
==========================================================================================================================================================
Q5
#include<stdio.h>

int main()
{
	int *p;
	
	p=(int*)malloc(sizeof(int));
	
	*p=400;
	
	printf("value : %d",*p);
	
	free(p);
}
=====================================================================================================================================================================
Q6
#include<stdio.h>
#include<stdlib.h>
#define SIZE 7


typedef struct st
{
int top;
char elements[SIZE];
}stack;


void initialize(stack *sp)
{
sp->top=-1;
}


void push(stack *sp,int item)
{
if(is_full(sp))
printf("\nstack overflow");
else
sp->elements[++sp->top]=item;
}


int pop(stack *sp)
{
int x;
if(is_empty(sp))
printf("\nstack underflow");
else
x=sp->elements[sp->top--];
return x;
}


int is_full(stack *sp)
{
if(sp->top==SIZE-1)
return 1;
else
return 0;
}


int is_empty(stack *sp)
{
if(sp->top== -1)
return 1;
else
return 0;
}


int main()
{
stack s1;
push(&s1,'N');
push(&s1,'I');
push(&s1,'M');
push(&s1,'E');
push(&s1,'S');
push(&s1,'H');
int i;
for(i=s1.top;i!=-1;--i)
{
printf("%c",s1.elements[i]);
}

}
==============================================================================================================================================================
Q7
#include<stdio.h>
#include<stdlib.h>
#define SIZE 5

typedef struct queue

{
int front;
int rear;
double elements[SIZE];
}queue;

void initialize(queue *qp)
{
qp->front=-1;
qp->rear=-1;
}
void add(queue *qp,double item)
{
if(qp->rear==SIZE-1)
printf("\nqueue overflow");
else
{
if(qp->front == -1)
qp->front=0;
qp->elements[++qp->rear]=item;
}
}
int rem(queue *qp)
{
char x;
if(qp->front==-1)
printf("\nqueue underflow");
else
x=qp->elements[qp->front++];
return x;
}

void display(queue *qp)
{
 int i;
 for(i=qp->front;i<=qp->rear;i++)
  {
    printf("double values : %lf\n",qp->elements[i]);
  }
}

int main()
{
queue *qp;
qp=(queue*)malloc(sizeof(queue));

initialize(qp);
add(qp,1);
add(qp,2);
add(qp,3);
add(qp,4);
add(qp,5);
display(qp);
}
==================================================================================================================================================
Q8
#include<stdio.h>
#include<stdlib.h>
#define SIZE 3

 

typedef struct a_st
{
    int Atop;
    char Aelements[SIZE];
}A;

 

typedef struct b_st
{
    int Btop;
    int Belements[SIZE];
}B;

 

void Ainitialize(A *sp)
{
    sp->Atop=-1;
}

 

void Binitialize(B *sp)
{
    sp->Btop=-1;
}

 

void Apush(A *sp,char item)
{
    if(A_is_full(sp))
    printf("\nstack overflow\n");
    
    else
    sp->Aelements[++sp->Atop]=item;
}

 

void Bpush(B *sp,int item)
{
    if(B_is_full(sp))
    printf("\nstack overflow\n");
    
    else
    sp->Belements[++sp->Btop]=item;
}

 

int Apop(A *sp)
{
    int x;
    
    if(A_is_empty(sp))
    printf("\nstack underflow");
    
    else
    x=sp->Aelements[sp->Atop--];
    
    return x;
}

 

int Bpop(B *sp)
{
    int x;
    
    if(B_is_empty(sp))
    printf("\nstack underflow");
    
    else
    x=sp->Belements[sp->Btop--];
    
    return x;
}

 

int A_is_full(A*sp)
{
    if(sp->Atop == SIZE-1)
    return 1;
    
    else
    return 0;
}

 

int B_is_full(B *sp)
{
    if(sp->Btop == SIZE-1)
    return 1;
    
    else
    return 0;
}

 

int A_is_empty(A *sp)
{
    if(sp->Atop == -1)
    return 1;
    
    else
    return 0;
}

 

int B_is_empty(B *sp)
{
    if(sp->Btop == -1)
    return 1;
    
    else
    return 0;
}

 

void A_display(A *sp)
{
    int i;
    
    for(i=sp->Atop;i!=-1;i--)
    {
        printf("%c",sp->Aelements[i]);
    }
    
    printf("\n\n");
}

 

void B_display(B *sp)
{
    int i;
    
    for(i=sp->Btop;i!=-1;i--)
    {
        printf("%d",sp->Belements[i]);
    }
    
    printf("\n\n");
}

 

int main()
{
     A a;
    
    Ainitialize(&a);
    
    Apush(&a,'a');
    Apush(&a,'b');
    Apush(&a,'c');
    
    A_display(&a);
    
    B b;
    
    Binitialize(&b);
    
    Bpush(&b,1);
    Bpush(&b,2);
    Bpush(&b,3);
    
    B_display(&b);
    
    
}
============================================================================================================================
Q9
#include<stdio.h>
#include<stdlib.h>
#define SIZE 5

typedef struct queue

{
int front;
int rear;
double elements[SIZE];
}queue;

void initialize(queue *qp)
{
qp->front=-1;
qp->rear=-1;
}
void add(queue *qp,double item)
{
if(qp->rear==SIZE-1)
printf("\nqueue overflow");
else
{
if(qp->front == -1)
qp->front=0;
qp->elements[++qp->rear]=item;
}
}
int rem(queue *qp)
{
char x;
if(qp->front==-1)
printf("\nqueue underflow");
else
x=qp->elements[qp->front++];
return x;
}

void display(queue *qp)
{
 int i;
 for(i=qp->front;i<=qp->rear;i++)
  {
    printf("double values : %lf\n",qp->elements[i]);
  }
}

int main()
{
queue *qp;
qp=(queue*)malloc(sizeof(queue));

initialize(qp);
add(qp,1);
add(qp,2);
add(qp,3);
add(qp,4);
add(qp,5);
display(qp);
}
=================================================================================================================
Q10
#include<stdio.h>
#define SIZE 5
 
typedef struct queue
 
{
   int front;
   int rear;
   int elements[SIZE];
 
}queue;
 
void initialize(queue *qp)
{
    qp->front=-1;
    qp->rear=-1;
}
 
void add(queue *qp,int item)
{
    if(qp->rear==SIZE-1)
    printf("\nqueue OVERFLOW");
    else
   
    qp->elements[++qp->rear]=item;
}
int rem(queue*qp)
{
	char x;
	if(qp->front==-1)
	printf("\nqueue underflow");
	else
	x=qp->elements[qp->front++];
	return x;
}

void display(queue *qp)
{
	int i;
	for(i=qp->front;i<=qp->rear;i++)
	{
		printf("square values are :%d\n",(qp->elements[i])*(qp->elements[i]));
	}
}
int main()
{
	queue *qp;
	qp=(queue*)malloc(sizeof(queue));
	initialize(qp);
	add(qp,2);
	add(qp,4);
	add(qp,8);
	add(qp,10);
	
	display(qp);
}
===============================================================================================================================================================
Q13
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#define SIZE 5

typedef struct a_st
{
	int Atop;
	char Aelements[SIZE];	
}A;
typedef struct b_st
{
	int Btop;
	char Belements[SIZE];	
}B;


void Ainitialize(A *sp)
{
	sp->Atop=-1;
}
void Binitialize(B *sp)
{
	sp->Btop=-1;
}

void Apush(A *sp,char item)
{
		if(A_is_full(sp))	
			printf("\nStack overflow\n");
		else
			sp->Aelements[++sp->Atop]=item;
}
void Bpush(B *sp,char item)
{
		if(B_is_full(sp))	
			printf("\nStack overflow\n");
		else
			sp->Belements[++sp->Btop]=item;
}


int Apop(A *sp)
{
	int x;
	if(A_is_empty(sp))
		printf("\nStack underflow");
	else
		x=sp->Aelements[sp->Atop--];
	return x;	
}

int A_is_full(A*sp)   
{
	if(sp->Atop == SIZE-1)      
		return 1;
	else
		return 0;
}
int B_is_full(B*sp)   
{
	if(sp->Btop == SIZE-1)      
		return 1;
	else
		return 0;
}


int A_is_empty(A *sp)   
{
	if(sp->Atop == -1)          
		return 1;
	else
		return 0;	
}
int B_is_empty(B*sp)   
{
	if(sp->Btop == -1)          
		return 1;
	else
		return 0;	
}
void A_display(A *sp)
{
	int i;
	
	for(i=sp->Atop;i!=-1;i--)
	{
		printf("%d ",sp->Aelements[i]);	
	}	
	printf("\n\n");
}

void B_display(B *sp)
{
	int i;
	
	for(i=sp->Btop;i!=-1;i--)
	{
		printf("%d ",sp->Belements[i]);	
	}	
	printf("\n\n");
}

int main()
{
	A a;
	Ainitialize(&a);
	B b;
	Binitialize(&b);
	int *p1;
	p1=&a;
	int i,j;
	for(i=0;i<SIZE;i++)
	{
		printf("Enter Number :");
		scanf("%d",&j);
		Apush(&a,j);
		Bpush(&b,j);
	}
	A_display(&a);
	printf("\n");
	B_display(&b);	
}
=====================================================================================================================================================
Q14
#include<stdio.h>
#include<stdlib.h>
#define SIZE 7


typedef struct st
{
    int top;
    int elements[SIZE];
}stack;


void initialize(stack *sp)
{
    sp->top=-1;
}


void push(stack *sp,int item)
{
    if(is_full(sp))
    printf("\nstack overflow");
    
    else
    sp->elements[++sp->top]=item;
}


int pop(stack *sp)
{
    int x;
    
    if(is_empty(sp))
    printf("\nstack underflow");
    
    else
    x=sp->elements[sp->top--];
    
    return x;
}


int is_full(stack *sp)
{
    if(sp->top==SIZE-1)
    return 1;
    
    else
    return 0;
}


int is_empty(stack *sp)
{
    if(sp->top==-1)
    return 1;
    
    else
    return 0;
}


void display(stack *sp)
{
    int i;
    
    for(i=sp->top;i!=-1;i++)
    {
        printf("%d",sp->elements[i]);
    }
    
    printf("\n");
}


int main()
{
    stack s1;
    initialize(&s1);
    
    int i,j;
    for(i=s1.top;i<4;i++)
    {
        printf("enter the number : ");
        scanf("%d",&j);
        push(&s1,j);
    }
    display(&s1);
    
}
================================================================================================================================================
Q15
#include<stdio.h>
#include<stdlib.h>

typedef struct nd
{
   char data;
   struct nd *next;
}node;

typedef struct ls
{
   node *head,*tail;
}list;

node* createNode(char no)
{
   node *np;
   np=(node*)malloc(sizeof(node));
   if(np == NULL)
{
   printf("Memory not available");
   exit(0);
}
   np->data=no;
   np->next=NULL;
   
   return np;
}

void initalize(list *p)
{
   p->head = NULL;
   p->tail = NULL;
}

void insertAtail(list *p,char x)
{
    node *np;
    np = createNode(x);
    if(p->head==NULL)
    p->head = np;
    else
    p->tail->next = np;
    p->tail = np;
}

void traverse(list *p)
{
   node *sp;
   sp = p->head;
   while(sp!=NULL)
  {
     printf("%c\n",sp->data);
     sp=sp->next;
  }
}
int main()
{
   list *p;
   p = (list*) malloc(sizeof(list));
   if(p == NULL)
  {
    printf("MEMORY UNVAVAILABLE");
    exit(0);
  }
  initalize(p);
  insertAtail(p,'A');
  insertAtail(p,'B');
  insertAtail(p,'C');
  insertAtail(p,'D');
  insertAtail(p,'E');
  traverse(p);
  
  free(p);
	
		
}
===================================================================================
Q.16 
#include<stdio.h> 
#include<stdlib.h>

//MULTIPLE NODES
 
typedef struct st
 
{

 
int data;

 
struct nd *next;

 
}node;

 
typedef struct ls

 
{

 
node *head,*tail;

 
}list;

 
void initialize(list *s)

 
{

 
s->head = NULL;

 
s->tail = NULL;

 
}

 
node* createnode(int x)

 
{

 
node *sp;

 
sp = (node*)malloc(sizeof(node));

 
if(sp == NULL)

 
{

 
printf("Memoy not avaliable");

 
exit(0);

 
}
 
sp->data = x;

 
sp->next = NULL;

 
return sp;

 
}

 
void insertAtail(list *s,int x)

 
{

 
node *sp;

 
sp=createnode(x);

 
if(s->head==NULL)

 
s->head=sp;

 
else

 
s->tail->next=sp;

 
s->tail=sp;

 
}

 
void traverse(list *s)

 
{

 
node *p;

 
p=s->head;

 
while(p!=0)

 
{

 
printf("%d\n",p->data);

 
p=p->next;

 
}

 
}

 
int getnodes(list *s)

 
{

 
node *p;

 
int count=0;

 
for(p=s->head;p!=NULL;p=p->next)

 
{

 
++count;

 
}

 
return count;

 
}

 
int main()

 
{

 
list *s;

 
s=(list*)malloc(sizeof(list));

 
if(s == NULL)

 
{

 
printf("Memory not available");

 
exit(0);

 
}

 
initialize(s);

 
insertAtail(s,100);

 
insertAtail(s,200);

 
insertAtail(s,300);

 
traverse(s);

 
int count = getnodes(s);
 
printf("NO. OF NODES : %d",count);

 
}


==========================================================================================
Q.17 
#include<stdio.h>
#include<conio.h>

 void main()
{
    char str[10]={'J','o','s','e','p','h','i','n','e'};
    
    char ch,flag;
    
    printf("\nEnter character  which is to be searched : ");
    scanf("%c",&ch);
    
    int i;
    for(i=0;i<10;i++)
    {
        if(str[i] == ch)
        {
            flag = i+1;
            break;
        }
        
        else
        flag = 0;
    }
    
    if(flag !=0)
    {
        printf("\ncharacter found at location %d\n",flag,ch);
        
    }
    
    else
    {
        printf("\ncharacter not found \n");
    }
}
==================================================================================================================================
Q.18
#include<stdio.h>
#include<stdlib.h>

typedef struct nd             
{                           
    char data;
    struct nd *next;
}node;

typedef struct ls
{
	node *head,*tail;
}list;

node* createNode(char no)
{
    node *np;
    
    np=(node*)malloc(sizeof(node));  
    
    if(np == NULL)
    {
        printf("Memory not available");
        exit(0);    
    }
    
    np->data=no;
    np->next=NULL;
    
    return np;
}

void initalize(list *p)
{
	p->head = NULL;
	p->tail = NULL;
}
void insertAtail(list *p,char x)
{
	node *np;
	np = createNode(x);
	if(p->head==NULL)
	p->head = np;
	else
	p->tail->next = np;
	p->tail = np;
}

void traverse(list *p)
{
    node *sp;
    int c=0;
    sp=p->head;
    printf("LIST IS :");
    while(sp!=NULL)
    {
    	printf("%d ",sp->data);
    	sp=sp->next;
    	c++;
	}
	
	int arr[c];
	sp=p->head;
	int i=c-1;
	while(sp!=NULL)
	{
		arr[i]=sp->data;
		sp=sp->next;
		i--;
	}
	
	printf("\nLINKED LIST IN REVERSE ORDER : ");
	for(i=0;i<c;i++)
	{
		printf("%d ",arr[i]);
	}
}
int main()
{    
    list *p;
    
    p = (list*) malloc(sizeof(list));
    
    if(p == NULL)
    {
    	printf("MEMORY UNVAVAILABLE");
    	exit(0);
	}
	
	initalize(p);
	insertAtail(p,'A');
	insertAtail(p,'B');
	insertAtail(p,'C');
	insertAtail(p,'D');
	insertAtail(p,'E');
	
	traverse(p);
	
	free(p);
    
}

=================================================================================================================================
Q.19 
#include<stdio.h>
#include<stdlib.h>
//MULTIPLE NODES
typedef struct st
{
	char data;
	struct nd *next;
}node;

typedef struct ls
{
	node *head,*tail;
}list;

void initialize(list *s)
{
	s->head = NULL;
	s->tail = NULL;
}

node* createnode(char* x)
{
	node *sp;
	
	sp = (node*)malloc(sizeof(node));
	
	if(sp == NULL)
	{
		printf("MEMORY UNAVAILABLE");
		exit(0);
	}
	
	sp->data = x;
	sp->next = NULL;
	
	return sp;
}

void insertAtail(list *s,char *x)
{
	node *sp;
	
	sp=createnode(x);
	if(s->head==NULL)
	s->head=sp; 
	else
	s->tail->next=sp;
	s->tail=sp;
}

void traverse(list *s)
{
	node *p;
	
	p=s->head->next;
	
	while(p!=0)
	{
		printf("%c\n",p->data);
		p=p->next;
	}
}

int main()
{
	list *s;
	
	s=(list*)malloc(sizeof(list));
	
	if(s == NULL)
	{
		printf("MEMORY UNAVAILABLE");
		exit(0);
	}
	
	initialize(s);
	
	insertAtail(s,'C');
	insertAtail(s,'D');
	insertAtail(s,'G');
	
	
	traverse(s);
}
    
=======================================================================================
Q20
#include<stdio.h>
#include<string.h>
int main()
{
    char data[100][100],search[50];
    int i,c=0;
    for(i=0;i<3;i++)
    {
        printf("Enter City Name %d : = ",i+1);
        scanf("%s",data[i]);
    }
    printf("\nCity Name are:\n");
    for(i=0;i<3;i++)
    {
        printf("%s\t",data[i]);
    }
    printf("\n\nEnter Name to be Searched: ");
    scanf("%s",search);
    for(i=0;i<3;i++)
    {
        if(strcmp(data[i],search)==0)
        {
            c=1;
            break;
        }
    }
    if(c==1)
        printf("\n%s Found at Position '%d'",data[i],i+1);
    else
        printf("\n%s NOT Present in Above Array",data[i]);
    return 0;
}
